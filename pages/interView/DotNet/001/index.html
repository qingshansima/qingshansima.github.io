<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DotNet面试题汇总 | 土肥猿的面经园地</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="程序员的面经园地和知识仓库">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.8a73fe64.css" as="style"><link rel="preload" href="/assets/js/app.7d1116cd.js" as="script"><link rel="preload" href="/assets/js/2.f6c26bfc.js" as="script"><link rel="preload" href="/assets/js/3.7a437186.js" as="script"><link rel="preload" href="/assets/js/10.046d08d1.js" as="script"><link rel="prefetch" href="/assets/js/11.5c5abcc8.js"><link rel="prefetch" href="/assets/js/12.f62d9829.js"><link rel="prefetch" href="/assets/js/13.4da237a9.js"><link rel="prefetch" href="/assets/js/14.48133eb7.js"><link rel="prefetch" href="/assets/js/15.48a2e085.js"><link rel="prefetch" href="/assets/js/16.81c035c3.js"><link rel="prefetch" href="/assets/js/17.5efa7f95.js"><link rel="prefetch" href="/assets/js/18.86e07264.js"><link rel="prefetch" href="/assets/js/19.2c2a487d.js"><link rel="prefetch" href="/assets/js/20.c4ffcb54.js"><link rel="prefetch" href="/assets/js/21.51a48402.js"><link rel="prefetch" href="/assets/js/22.bf514554.js"><link rel="prefetch" href="/assets/js/23.d4182788.js"><link rel="prefetch" href="/assets/js/24.4dbd20f7.js"><link rel="prefetch" href="/assets/js/25.700af0f5.js"><link rel="prefetch" href="/assets/js/26.ae7d5d12.js"><link rel="prefetch" href="/assets/js/27.1d660e1f.js"><link rel="prefetch" href="/assets/js/28.e301b416.js"><link rel="prefetch" href="/assets/js/29.0fd72cb1.js"><link rel="prefetch" href="/assets/js/30.63cb3594.js"><link rel="prefetch" href="/assets/js/31.e64cb78c.js"><link rel="prefetch" href="/assets/js/32.fe425a1c.js"><link rel="prefetch" href="/assets/js/33.27558bfc.js"><link rel="prefetch" href="/assets/js/34.d0b64862.js"><link rel="prefetch" href="/assets/js/4.9ccfb5d5.js"><link rel="prefetch" href="/assets/js/5.573dfa2c.js"><link rel="prefetch" href="/assets/js/6.655bfde6.js"><link rel="prefetch" href="/assets/js/7.babcfb3d.js"><link rel="prefetch" href="/assets/js/8.71593ea4.js"><link rel="prefetch" href="/assets/js/9.b9ccbf27.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8a73fe64.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/FatMonkey550.png" alt="土肥猿的面经园地" class="logo"> <span class="site-name can-hide">土肥猿的面经园地</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面经园地" class="dropdown-title"><a href="/pages/b5188c/" class="link-title">面经园地</a> <span class="title" style="display:none;">面经园地</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/java/001/" class="nav-link">Java基础面试高频问题1~80</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/002/" class="nav-link">Spring面试高频问题1~10</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/003/" class="nav-link">MyBatis面试高频问题1~18</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/004/" class="nav-link">Java架构师面试高频问题</a></li></ul></li><li class="dropdown-item"><h4>Dotnet</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/DotNet/001/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Dotnet面试题汇总1</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/DB/001/" class="nav-link">Oracle面试题1-33</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发笔记" class="dropdown-title"><a href="/pages/43f8ea/" class="link-title">开发笔记</a> <span class="title" style="display:none;">开发笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>架构设计</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/43f8ea/" class="nav-link">面向对象设计五大原则</a></li><li class="dropdown-subitem"><a href="/pages/e08693/" class="nav-link">微服务常用组件</a></li></ul></li><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Notes/java/001/" class="nav-link">Java常用中间件</a></li><li class="dropdown-subitem"><a href="/pages/Notes/java/002/" class="nav-link">Java常用工作流</a></li></ul></li><li class="dropdown-item"><h4>Python</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Notes/Python/miniServer/000/" class="nav-link">面向测试方法开发Python微服务</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中文翻译" class="dropdown-title"><!----> <span class="title" style="display:;">中文翻译</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Go语言文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/GoTour/000/" class="nav-link">序言和目录</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/001/" class="nav-link">Go语言的下载和安装</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/002/" class="nav-link">Go语言入门教程</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/003/" class="nav-link">Go模块教程</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/004/" class="nav-link">使用Go和Gin开发RESTful API</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/005/" class="nav-link">使用Go开发Web应用程序</a></li></ul></li><li class="dropdown-item"><h4>Python-PyAutoGui文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/python/PyAutoGui/001/" class="nav-link">1.Windows11下PyAutoGui的安装和使用</a></li></ul></li><li class="dropdown-item"><h4>微软UI自动化文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Microsoft/UIAutomation/000/" class="nav-link">UI自动化课程简介</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="职场随笔" class="dropdown-title"><a href="/pages/893e69/" class="link-title">职场随笔</a> <span class="title" style="display:none;">职场随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>失业笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day000/" class="nav-link">2003清明，失业第0天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day001/" class="nav-link">2003-04-06，失业第一周·第1天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day002/" class="nav-link">2003-04-07，失业第一周·第2天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day003/" class="nav-link">2003-04-08~09，失业第一周·双休</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day004/" class="nav-link">2003-04-08~09，失业第二周·第1天</a></li></ul></li></ul></div></div> <a href="https://github.com/qingshansima/qingshansima.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面经园地" class="dropdown-title"><a href="/pages/b5188c/" class="link-title">面经园地</a> <span class="title" style="display:none;">面经园地</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/java/001/" class="nav-link">Java基础面试高频问题1~80</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/002/" class="nav-link">Spring面试高频问题1~10</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/003/" class="nav-link">MyBatis面试高频问题1~18</a></li><li class="dropdown-subitem"><a href="/pages/interView/java/004/" class="nav-link">Java架构师面试高频问题</a></li></ul></li><li class="dropdown-item"><h4>Dotnet</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/DotNet/001/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Dotnet面试题汇总1</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/interView/DB/001/" class="nav-link">Oracle面试题1-33</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发笔记" class="dropdown-title"><a href="/pages/43f8ea/" class="link-title">开发笔记</a> <span class="title" style="display:none;">开发笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>架构设计</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/43f8ea/" class="nav-link">面向对象设计五大原则</a></li><li class="dropdown-subitem"><a href="/pages/e08693/" class="nav-link">微服务常用组件</a></li></ul></li><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Notes/java/001/" class="nav-link">Java常用中间件</a></li><li class="dropdown-subitem"><a href="/pages/Notes/java/002/" class="nav-link">Java常用工作流</a></li></ul></li><li class="dropdown-item"><h4>Python</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Notes/Python/miniServer/000/" class="nav-link">面向测试方法开发Python微服务</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中文翻译" class="dropdown-title"><!----> <span class="title" style="display:;">中文翻译</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Go语言文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/GoTour/000/" class="nav-link">序言和目录</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/001/" class="nav-link">Go语言的下载和安装</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/002/" class="nav-link">Go语言入门教程</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/003/" class="nav-link">Go模块教程</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/004/" class="nav-link">使用Go和Gin开发RESTful API</a></li><li class="dropdown-subitem"><a href="/pages/GoTour/005/" class="nav-link">使用Go开发Web应用程序</a></li></ul></li><li class="dropdown-item"><h4>Python-PyAutoGui文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/python/PyAutoGui/001/" class="nav-link">1.Windows11下PyAutoGui的安装和使用</a></li></ul></li><li class="dropdown-item"><h4>微软UI自动化文档中文翻译</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/Microsoft/UIAutomation/000/" class="nav-link">UI自动化课程简介</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="职场随笔" class="dropdown-title"><a href="/pages/893e69/" class="link-title">职场随笔</a> <span class="title" style="display:none;">职场随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>失业笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day000/" class="nav-link">2003清明，失业第0天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day001/" class="nav-link">2003-04-06，失业第一周·第1天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day002/" class="nav-link">2003-04-07，失业第一周·第2天</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day003/" class="nav-link">2003-04-08~09，失业第一周·双休</a></li><li class="dropdown-subitem"><a href="/pages/unemploymentLog/Day004/" class="nav-link">2003-04-08~09，失业第二周·第1天</a></li></ul></li></ul></div></div> <a href="https://github.com/qingshansima/qingshansima.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <div class="sidebar-slot sidebar-slot-top">
  <a href="http://apifox.cn/a103xugaoyi" target="_blank">
    <img src="https://cdn.staticaly.com/gh/xugaoyi/blog-gitalk-comment@master/img/431669861564_.2470ykdcpbds.jpg" alt="npm" class="no-zoom" style="width: 100%;border-radius: 2px;">
    <p style="text-align: center;margin: 0;color: #999;font-size: 12px;">(进入注册为作者充电)</p>
  </a></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/interView/java/001/" class="sidebar-link">Java基础面试高频问题1~80</a></li><li><a href="/pages/interView/java/002/" class="sidebar-link">Spring面试高频问题1~10</a></li><li><a href="/pages/interView/java/003/" class="sidebar-link">MyBatis面试高频问题1~18</a></li><li><a href="/pages/interView/java/004/" class="sidebar-link">Java架构师面试高频问题1~18</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>DotNet</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/interView/DotNet/001/" aria-current="page" class="active sidebar-link">DotNet面试题汇总</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/interView/DB/001/" class="sidebar-link">Oracle面试题1~33</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><span data-v-06970110>面经园地</span></li><li data-v-06970110><span data-v-06970110>DotNet</span></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://qingshansima.github.io" target="_blank" title="作者" class="beLink" data-v-06970110>飞翔的土肥猿</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2023-04-26</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">DotNet面试题汇总<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h4 id="_1-锁表原因及如何处理"><a href="#_1-锁表原因及如何处理" class="header-anchor">#</a> 1.锁表原因及如何处理</h4> <ol><li>锁表发生在insert  update 、delete 中</li> <li>锁表的原理是 数据库使用独占式封锁机制，当执行上面的语句时，对表进行锁住，直到发生commite 或者 回滚 或者退出数据库用户</li> <li>锁表的原因
<ul><li>A程序执行了对 tableA 的 insert ，并还未 commite时，B程序也对tableA 进行insert 则此时会发生资源正忙的异常 就是锁表</li> <li>锁表常发生于并发而不是并行（并行时，一个线程操作数据库时，另一个线程是不能操作数据库的，cpu 和i/o 分配原则）</li></ul></li> <li>减少锁表的概率，</li></ol> <ul><li>减少insert 、update 、delete 语句执行 到 commite 之间的时间。具体点批量执行改为单个执行、优化sql自身的非执行速度</li> <li>如果异常对事物进行回滚</li></ul> <h4 id="_2-乐观锁和悲观锁的区别"><a href="#_2-乐观锁和悲观锁的区别" class="header-anchor">#</a> 2.乐观锁和悲观锁的区别</h4> <p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p> <p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p> <p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p> <hr> <p>排它锁和共享锁
在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。<br>
当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。<br>
数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。</p> <p>表级锁和行级锁<br>
DML锁的目的在于保证并发情况下的数据完整性，主要包括TM锁和TX锁，其中TM锁称为表级锁，TX锁称为事务锁或行级锁。<br>
当Oracle执行DML语句时，系统自动在所要操作的表上申请TM类型的锁。当TM锁获得后，系统再自动申请TX类型的锁，并将实际锁定的数据行的锁标志位进行置位。这样在事务加锁前检查TX锁相容性时就不用再逐行检查锁标志，而只需检查TM锁模式的相容性即可，大大提高了系统的效率。TM锁包括了SS、SX、S、X等多种模式，在数据库中用0－6来表示。不同的SQL操作产生不同类型的TM锁。</p> <h4 id="_3-缓存"><a href="#_3-缓存" class="header-anchor">#</a> 3.缓存</h4> <ul><li>不需要实时更新但是又极其消耗数据库的数据。比如网站上商品销售排行榜，这种数据一天统计一次就可以了，用户不会关注其是否是实时的。</li> <li>需要实时更新，但是更新频率不高的数据。比如一个用户的订单列表，他肯定希望能够实时看到自己下的订单，但是大部分用户不会频繁下单。</li> <li>在某个时刻访问量极大而且更新也很频繁的数据。这种数据有一个很典型的例子就是秒杀，在秒杀那一刻，可能有N倍于平时的流量进来，系统压力会很大。但是这种数据使用的缓存不能和普通缓存一样，这种缓存必须保证不丢失，否则会有大问题。</li></ul> <h4 id="_4-mvc特点"><a href="#_4-mvc特点" class="header-anchor">#</a> 4.MVC特点</h4> <p>M：Modle（模型，主要是Service业务逻辑层和Dao和数据库取得连接并发送数据的层）
V：VIEW（视图，也就是用户看的界面，通常是我们所熟知的前台页面，jsp等）
C：CONTROLLER（控制层，可以把他看作一个中转，他接收从前台用户发来的请求，并调用service,dao把数据发送到后台，后台经过数据库的操作及业务逻辑分析又将数据返回给controller，最后再返回前台jsp页面）。</p> <p>说说MVC的优缺点，
优点:</p> <ol><li>MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。</li> <li>降低了层与层之间的依赖，有利于代码的标准化开发</li> <li>再用新的代码业务逻辑替换时，只需要替换相对应的层，大大降低了我们的工作量，分工明确。</li></ol> <h4 id="_5-大数据存储解决方案"><a href="#_5-大数据存储解决方案" class="header-anchor">#</a> 5.大数据存储解决方案</h4> <ul><li><p><strong>分区</strong>
将数据库分区可提高其性能并易于维护。通过将一个大表拆分成更小的单个表，只访问一小部分数据的查询可以执行得更快，因为需要扫描的数据较少。而且可以更快地执行维护任务（如重建索引或备份表）。
实现分区操作时可以不拆分表，而将表物理地放置在个别的磁盘驱动器上。例如，将表放在某个物理驱动器上并将相关的表放在与之分离的驱动器上可提高查询性能，因为当执行涉及表之间联接的查询时，多个磁头同时读取数据。</p></li> <li><p><strong>硬件分区</strong>
硬件分区将数据库设计为利用可用的硬件构架。</p></li> <li><p><strong>水平分区</strong>
水平分区将一个表分段为多个表，每个表包含相同数目的列和较少的行。例如，可以将一个包含十亿行的表水平分区成12个表，每个小表代表特定年份内一个月的数据。任何需要特定月份数据的查询只引用相应月份的表。</p></li> <li><p><strong>垂直分区</strong>
垂直分区将一个表分段为多个表，每个表包含较少的列。垂直分区的两种类型是规范化和行拆分。</p></li></ul> <h4 id="_6-redis容灾策略"><a href="#_6-redis容灾策略" class="header-anchor">#</a> 6.redis容灾策略</h4> <p>基本的redis的容灾策略为：</p> <ol><li>采用master-slave方式</li> <li>为了得到好的读写性能，master不做任何的持久化</li> <li>slave同时开启Snapshot和AOF来进行持久化，保证数据的安全性</li> <li>当master挂掉后，修改slave为master</li> <li>恢复原master数据，修改原先master为slave，启动slave</li> <li>若master与slave都挂掉后，调用命令通过aof和snapshot进行恢复
恢复时要先确保恢复文件都正确了，才能启动主库；也可以先启动slave，将master与slave对调
开源方案codis<a href="http://navyaijm.blog.51cto.com/4647068/1637688" target="_blank" rel="noopener noreferrer">http://navyaijm.blog.51cto.com/4647068/1637688<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <p>哨兵的作用</p> <ul><li>监控：监控主从是否正常</li> <li>通知：出现问题时，可以通知相关人员</li> <li>故障迁移：自动主从切换</li> <li>统一的配置管理：连接者询问sentinel取得主从的地址
Raft算法核心: 可视图</li></ul> <h4 id="_7-redis常用五大数据类型"><a href="#_7-redis常用五大数据类型" class="header-anchor">#</a> 7.Redis常用五大数据类型</h4> <ol><li>String（字符串）
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</li> <li>Hash（哈希）
Redis hash 是一个键值对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
类似Java里面的Map&lt;String,Object&gt;</li> <li>List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。
它的底层实际是个链表</li> <li>Set（集合）
Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</li> <li>zset(sorted set：有序集合)
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。
redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</li></ol> <h3 id="solr"><a href="#solr" class="header-anchor">#</a> Solr</h3> <h4 id="_8-rabbitmq汇总"><a href="#_8-rabbitmq汇总" class="header-anchor">#</a> 8.rabbitMQ汇总</h4> <h5 id="rabbitmq特点"><a href="#rabbitmq特点" class="header-anchor">#</a> rabbitMQ特点</h5> <ol><li>可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li> <li>灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li> <li>消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li> <li>高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li> <li>多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li> <li>多语言客户端（Many Clients）RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li> <li>管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li> <li>跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li> <li>插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li></ol> <h5 id="rabbitmq概念"><a href="#rabbitmq概念" class="header-anchor">#</a> RabbitMQ概念</h5> <p>ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。
Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p> <blockquote><h5 id="消息回执-message-acknowledgment"><a href="#消息回执-message-acknowledgment" class="header-anchor">#</a> 消息回执（Message acknowledgment）</h5></blockquote> <p>在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开</p> <blockquote><h5 id="消息持久化-message-durability"><a href="#消息持久化-message-durability" class="header-anchor">#</a> 消息持久化（Message durability）</h5></blockquote> <p>如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。</p> <blockquote><h5 id="交换器-exchange"><a href="#交换器-exchange" class="header-anchor">#</a> 交换器 Exchange</h5></blockquote> <p>RabbitMQ中的Exchange有四种类型，不同的类型有着不同的路由策略</p> <blockquote><h5 id="routing-key"><a href="#routing-key" class="header-anchor">#</a> routing key</h5></blockquote> <p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。
在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。
RabbitMQ为routing key设定的长度限制为255 bytes</p> <blockquote><h5 id="exchange-types"><a href="#exchange-types" class="header-anchor">#</a> Exchange Types</h5></blockquote> <p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），下面分别进行介绍。</p> <ol><li>Fanout Exchange 不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。</li> <li>Direct Exchange 处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “test”，则只有被标记为“test”的消息才被转发，不会转发test.aaa，也不会转发dog.123，只会转发test。</li> <li>Topic Exchange 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号 <code>#</code> 匹配一个或多个词，符号 <code>*</code> 匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”。</li></ol> <p><a href="http://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html" target="_blank" rel="noopener noreferrer">详细资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_9-c-垃圾回收机制"><a href="#_9-c-垃圾回收机制" class="header-anchor">#</a> 9.C# 垃圾回收机制</h4> <p>用到GC，命名空间System.GC;
可以强制回收 GC.Collect()</p> <ul><li>什么是GC
GC如其名，就是垃圾收集，当然这里仅就内存而言。Garbage Collector（垃圾收集器，在不至于混淆的情况下也成为GC）以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象[2]，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。这就是GC工作的原理。为了实现这个原理，GC有多种算法。比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.NET CLR，Java VM和Rotor都是采用的Mark Sweep算法。</li></ul> <h5 id="_10-net的gc机制有这样两个问题"><a href="#_10-net的gc机制有这样两个问题" class="header-anchor">#</a> 10..NET的GC机制有这样两个问题</h5> <ul><li>首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。</li> <li>第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。</li></ul> <blockquote><p>GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using语句可以简化资源管理。</p></blockquote> <h5 id="_11-gc注意事项"><a href="#_11-gc注意事项" class="header-anchor">#</a> 11.GC注意事项</h5> <ol><li>只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理。</li> <li>循环引用，网状结构等的实现会变得简单。GC的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。</li> <li>GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。</li> <li>GC在一个独立的线程中运行来删除不再被引用的内存。</li> <li>GC每次运行时会压缩托管堆。</li> <li>你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。</li> <li>对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数</li> <li>Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。</li> <li>.NET GC使用&quot;代&quot;(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。</li> <li>GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。</li></ol> <h4 id="_12-dotnet-异常处理"><a href="#_12-dotnet-异常处理" class="header-anchor">#</a> 12.Dotnet 异常处理</h4> <p>C# 语言的异常处理功能有助于处理在程序运行期间发生的任何意外或异常情况。 异常处理功能使用 try、catch 和 finally 关键字来尝试执行可能失败的操作、在你确定合理的情况下处理故障，以及在事后清除资源。 公共语言运行时 (CLR)、.NET Framework/任何第三方库或应用程序代码都可以生成异常。 异常是使用 throw 关键字创建而成。</p> <h4 id="_13-dotnet-不能被继承类"><a href="#_13-dotnet-不能被继承类" class="header-anchor">#</a> 13.Dotnet 不能被继承类</h4> <p>在C#中定义了关键字sealed，被sealed修饰的类不能够被继承。在Java中同样也有关键字final表示一个类不能被继承。C++11提供final关键字使得类不能够被继承。</p> <h4 id="_14-c-栈和堆"><a href="#_14-c-栈和堆" class="header-anchor">#</a> 14.C#栈和堆</h4> <p>我们把内存分为堆空间和栈空间</p> <blockquote><p>线程堆栈：简称栈 Stack 栈空间比较小，但是读取速度快
托管堆： 简称堆 Heap 堆空间比较大，但是读取速度慢</p></blockquote> <hr> <p>栈的特征：数据只能从栈的顶端插入和删除把数据放入栈顶称为入栈（push）从栈顶删除数据称为出栈（pop）<br>
堆：堆是一块内存区域，与栈不同，堆里的内存能够以任意顺序存入和移除</p> <h5 id="_15-栈-vs-堆-区别"><a href="#_15-栈-vs-堆-区别" class="header-anchor">#</a> 15.栈 vs 堆：区别？</h5> <p>栈通常保存着我们代码执行的步骤，而堆上存放的则多是对象，数据等。我们可以把栈想象成一个接着一个叠放在一起的盒子。当我们使用的时候，每次从最顶部取走一个盒子。栈也是如此，当一个方法（或类型）被调用完成的时候，就从栈顶取走，接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。</p> <hr> <p>栈存储的是基本值类型，堆存储的是new出来的对象。引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。
当我们程序执行的时候，在栈和堆中分配有四种主要的类型：值类型，引用类型，指针，指令。</p> <hr> <p>栈：所分配的内存是在一块连续的内存区域内．当我们声明变量时，那么编译器会自动接着当前栈区的结尾来分配内存<br>
堆：一般由程序员分配释放(new)， 若程序员不释放，程序结束时可能由操作系统回收</p> <h4 id="_16-数据库如何优化"><a href="#_16-数据库如何优化" class="header-anchor">#</a> 16.数据库如何优化</h4> <ol><li>数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。</li> <li>数据库索引方面的优化：比如常用的字段建索引，联合查询考虑联合索引。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）</li> <li>数据库查询方面的优化：避免select * 的写法、尽量不用in和not in 这种耗性能的用法等等</li> <li>数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等</li></ol> <h4 id="_17-你在你以前的项目中-主要解决了什么技术性难题-如果出现问题-你如何迅速找到问题-你遇到问题都是怎么解决的"><a href="#_17-你在你以前的项目中-主要解决了什么技术性难题-如果出现问题-你如何迅速找到问题-你遇到问题都是怎么解决的" class="header-anchor">#</a> 17.你在你以前的项目中，主要解决了什么技术性难题，如果出现问题，你如何迅速找到问题，你遇到问题都是怎么解决的</h4> <ol><li>先根据出现的问题，大概排查出问出问题的几个点，逐个排查， 错误日志- sql查询计划-定位程序错误，</li> <li>技术性难题： 自己解决---csdn(博客园)---谷歌---请教技术大牛</li> <li>解决的技术难题：
<ul><li>微信支付，苹果和安卓的支付力度不一样</li> <li>消息推送 signalr(以前是长轮询)</li></ul></li></ol> <h4 id="_18-项目中你用到的设计模式有哪些-举例说明"><a href="#_18-项目中你用到的设计模式有哪些-举例说明" class="header-anchor">#</a> 18.项目中你用到的设计模式有哪些,举例说明</h4> <p>单例：可以保证系统中一个类只有一个实例，并且自行实例化向整个系统提供(例如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务)<br>
最简单的就是写考虑线程安全的单例模式</p> <div class="language-CSharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义一个静态变量来保存类的实例</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token comment">// 定义一个标识确保线程同步</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name"><span class="token keyword">object</span></span> locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">object</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 定义私有构造函数，使外界不能创建该类实例</span>
    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Singleton</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 双重锁定只需要一句判断就可以了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">lock</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果类的实例不存在则创建，否则直接返回</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_19-数据库的索引失效"><a href="#_19-数据库的索引失效" class="header-anchor">#</a> 19.数据库的索引失效？</h4> <p>删掉索引,然后再重建索引</p> <h4 id="_20-iis-经典模式和集成模式的区别"><a href="#_20-iis-经典模式和集成模式的区别" class="header-anchor">#</a> 20.IIS 经典模式和集成模式的区别</h4> <ul><li>经典形式是为了与之前的版本兼容，运用ISAPI扩展来调用ASP.NET运转库</li> <li>集成形式是一种统一的请求处置管道，它将ASP.NET请求管道与IIS中心管道组合在一同，这种形式可以提供更好的性能，可以完成配置和管理的模块化，而且增加了运用托管代码模块扩展IIS时的灵敏性。</li></ul> <p>假设老的Web应用程序运转于IIS7.0的集成形式下， 可能需求对应用程序的web.config文件停止修正，特别是运用了完成IHttpHandler接口的自定义模块的状况。IIS7.0在同一个效劳器上可以同时支持两种形式的应用程序。</p> <h4 id="_21-多线程-有几种启动方式"><a href="#_21-多线程-有几种启动方式" class="header-anchor">#</a> 21.多线程 有几种启动方式</h4> <p>使用new Thread()和new Thread(Runnable)形式</p> <ul><li>第一种直接调用thread的run方法，所以，往往使用Thread子类，new Thread(){}.start();这表示调用Thread子类对象的run方法，
new Thread(){}表示一个Thread的匿名子类的实例对象。</li> <li>第二种调用Runnable的run方法。
new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象</li></ul> <h4 id="_22-数据库锁有几种"><a href="#_22-数据库锁有几种" class="header-anchor">#</a> 22.数据库锁有几种</h4> <ul><li>共享-S锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。</li> <li>排它-X锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。</li> <li>更新-U锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</li></ul> <h4 id="_23-两个html页面之间怎么传递参数值"><a href="#_23-两个html页面之间怎么传递参数值" class="header-anchor">#</a> 23.两个html页面之间怎么传递参数值</h4> <ol><li>如果页面A和页面B是同域的情况,使用Cookie传递参数 ，a页面保存Cookie，b页面读取</li> <li>如果页面A和页面B不同域的情况,页面A通过点击链接跳转到页面B的话，那么数据可以通过search和hash附加在B页面的URL上，传递给页面B,window对象它们是共享的，因此我们可以通过window.xx来传递数据，比如window.name=123;</li> <li>如果页面A和B，不同域，也没有跳转关系,如果浏览器支持HTML5的话，我们可以使用window.postMessage来跨域发送数据。</li></ol> <h4 id="_24-viewdata和viewbag区别"><a href="#_24-viewdata和viewbag区别" class="header-anchor">#</a> 24.ViewData和ViewBag区别</h4> <h5 id="viewdata"><a href="#viewdata" class="header-anchor">#</a> ViewData</h5> <ul><li>ViewData是一个继承自ViewDataDictionary类的Dictionary对象。</li> <li>ViewData用来从Controller向对应的View传递值。</li> <li>ViewData的只在当前当前的请求中有效，生命周期和View相同，其值不能在多个请求中共享。</li> <li>在重定向(redirection)后，ViewData中存储的变量值将变为null。</li> <li>在取出ViewData中的变量值是，必须进行合适的类型转换(隐式或显式)和空值检查。</li></ul> <h5 id="viewbag"><a href="#viewbag" class="header-anchor">#</a> ViewBag</h5> <ul><li>ViewBag是一个动态类型变量(dynamic)，这是C# 4.0引入的新特性，变量类型会在运行时进行解析。</li> <li>ViewBag基本上是ViewData的包装，也是用来从Controller向View来传递值的。</li> <li>ViewBag也只在当前的请求中有效。</li> <li>在重定向(redirection)后，ViewBag中存储的变量值将变为null</li> <li>因为ViewBag是动态类型，所以我们在取得其值时，不需要进行类型转换。</li></ul> <h4 id="_25-装箱和取消装箱"><a href="#_25-装箱和取消装箱" class="header-anchor">#</a> 25.装箱和取消装箱</h4> <p>装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程。 当 CLR 对值类型进行装箱时，会将该值包装到 System.Object内部，再将后者存储在托管堆上。 取消装箱将从对象中提取值类型。 装箱是隐式的；取消装箱是显式的。 装箱和取消装箱的概念是类型系统 C#统一视图的基础，其中任一类型的值都被视为一个对象。</p> <h4 id="_26-数据库索引"><a href="#_26-数据库索引" class="header-anchor">#</a> 26.数据库索引</h4> <p>数据库索引有</p> <ul><li>sqlserver 主键索引、唯一索引、聚集索引、非聚集索引</li> <li>mysql 唯一索引（主键索引）、聚集索引、非聚集索引、全文索引</li></ul> <p><strong>唯一索引</strong><br>
唯一索引不允许两行具有相同的索引值。<br>
如果现有数据中存在重复的键值，则大多数数据库都不允许将新创建的唯一索引与表一起保存。当新数据将使表中的键值重复时，数据库也拒绝接受此数据。例如，如果在 employee 表中的职员姓氏(lname) 列上创建了唯一索引，则所有职员不能同姓。</p> <p><strong>主键索引</strong><br>
主键索引是唯一索引的特殊类型。<br>
数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键。
在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。</p> <p>它们的一些比较：</p> <ol><li>对于主健/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；</li> <li>主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；</li> <li>主健可作外健，唯一索引不可；</li> <li>主健不可为空，唯一索引可；</li> <li>主健也可是多个字段的组合；</li> <li>主键与唯一索引不同的是：
<ol><li>有not null属性</li> <li>每个表只能有一个。</li></ol></li></ol> <p><strong>聚集索引</strong><br>
一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。</p> <p><strong>非聚集索引</strong><br>
一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p> <blockquote><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</p></blockquote> <p>聚集索引：可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了。
非聚集索引：把一个很大的范围，转换成一个小的地图。你需要在这个小地图中找你要寻找的信息的位置。然后通过这个位置，再去找你所需要的记录。</p> <p><strong>使用场景</strong>
基于上述的两种规则，那么在什么时候适合聚集索引，什么时候适合非聚集索引？
<img src="https://gitee.com/uploads/images/2018/0601/174050_22832325_1248390.jpeg" alt="使用场景" title="20160127144445485.jpg"></p> <h4 id="_27-webapi和mvc有什么区别"><a href="#_27-webapi和mvc有什么区别" class="header-anchor">#</a> 27.WebApi和MVC有什么区别</h4> <p>Web API更倾向于基于HTTP协议的服务，直接返回用户的数据请求。MVC是建站的一种框架，倾向于返回用户的页面请求。
ASP.NET Web API 的特性，更能说明Web API是一种数据请求框架：</p> <ol><li>ASP.NET Web API 可以根据请求报文来返回的相应数据格式。包括JSON和XML。</li> <li>ASP.NET Web API 单独做数据请求和MVC做页面请求可以让Web前端和后台更好的解耦，减少开发难度。</li> <li>Web API 可以更好地用在移动端网页、桌面端网页或者桌面程序，调用方更加多样化。</li> <li>Web API 的宿主可以选择多样：WebHost,，ConsoleHost，甚至是windows Services。</li></ol> <blockquote><p>WebAPI主演提供了一套RestfulAPI的开发框架，提供了较为完整的http语义支持，主要用来做开放API，更抽象，更不注重View的生成。
MVC的主要使用场景在于Web站点的开发，他在后端实现了一套完整的MVC开发框架，能提供方便的页面开发，默认使用Razor视图引擎，提供了后端html构造，用户可以方便地开发出带页面的站点。</p></blockquote> <h4 id="_28-array和arraylist的区别"><a href="#_28-array和arraylist的区别" class="header-anchor">#</a> 28.Array和ArrayList的区别</h4> <ol><li>Array类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。</li> <li>Array只能存储同构的对象，而ArrayList可以存储异构的对象。
同构的对象是指类型相同的对象，若声明为int[]的数组就只能存放整形数据,string[]只能存放字符型数据,但声明为object[]的数组除外。</li> <li>在CLR托管对中的存放方式，Array是始终是连续存放的，而ArrayList的存放不一定连续。</li> <li>初始化大小 Array对象的初始化必须只定指定大小，且创建后的数组大小是固定的</li> <li>Array不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。</li></ol> <h4 id="_29-web-service-wcf-web-api"><a href="#_29-web-service-wcf-web-api" class="header-anchor">#</a> 29.Web Service，WCF， Web API</h4> <p>Web Service</p> <ol><li>它是基于SOAP协议的，数据格式是XML</li> <li>只支持HTTP协议</li> <li>它不是开源的，但可以被任意一个了解XML的人使用</li> <li>它只能部署在IIS上</li></ol> <p>WCF</p> <ol><li>这个也是基于SOAP的，数据格式是XML</li> <li>这个是Web Service（ASMX）的进化版，可以支持各种各样的协议，像TCP，HTTP，HTTPS，Named Pipes, MSMQ.</li> <li>WCF的主要问题是，它配置起来特别的繁琐</li> <li>它不是开源的，但可以被任意一个了解XML的人使用</li> <li>它可以部署应用程序中或者IIS上或者Windows服务中</li></ol> <p>WCF Rest</p> <ol><li>想使用WCF Rest service，你必须在WCF中使用webHttpBindings</li> <li>它分别用[WebGet]和[WebInvoke]属性，实现了HTTP的GET和POST动词</li> <li>要想使用其他的HTTP动词，你需要在IIS中做一些配置，使.svc文件可以接受这些动词的请求</li> <li>使用WebGet通过参数传输数据，也需要配置。而且必须指定UriTemplate</li> <li>它支持XML、JSON以及ATOM这些数据格式</li></ol> <p>Web API</p> <ol><li>这是一个简单的构建HTTP服务的新框架</li> <li>在.net平台上Web API 是一个开源的、理想的、构建REST-ful 服务的技术</li> <li>不像WCF REST Service.它可以使用HTTP的全部特点（比如URIs、request/response头，缓存，版本控制，多种内容格式）</li> <li>它也支持MVC的特征，像路由、控制器、action、filter、模型绑定、控制反转（IOC）或依赖注入（DI），单元测试。这些可以使程序更简单、更健壮</li> <li>它可以部署在应用程序和IIS上</li> <li>这是一个轻量级的框架，并且对限制带宽的设备，比如智能手机等支持的很好</li> <li>Response可以被Web API的MediaTypeFormatter转换成Json、XML 或者任何你想转换的格式。</li></ol> <h5 id="_30-wcf和web-api我该选择哪个"><a href="#_30-wcf和web-api我该选择哪个" class="header-anchor">#</a> 30.WCF和WEB API我该选择哪个？</h5> <ol><li>当你想创建一个支持消息、消息队列、双工通信的服务时，你应该选择WCF</li> <li>当你想创建一个服务，可以用更快速的传输通道时，像TCP、Named Pipes或者甚至是UDP（在WCF4.5中）,在其他传输通道不可用的时候也可以支持HTTP。</li> <li>当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择Web API</li> <li>当你想让你的服务用于浏览器、手机、iPhone和平板电脑时，你应该选择Web API</li></ol> <h4 id="_31-const和readonly关键字"><a href="#_31-const和readonly关键字" class="header-anchor">#</a> 31.const和readonly关键字</h4> <p>先来了解静态常量和动态常量。</p> <ul><li>静态常量：所谓静态常量就是在编译期间会对变量进行解析，再将常量的值替换成初始化的值。</li> <li>动态常量：所谓动态常量就是编译期间会将变量标记只读常量，而不用常量的值代替，这样在声明时可以不初始化，可以延迟到构造函数初始化。</li></ul> <p>const修饰的常量是上述中的第一种，即静态常量，而readonly是上述中第二种即动态常量。他们的区别可以从静态常量和动态常量的特性来说明：</p> <ul><li>const修饰的常量在声明时必须初始化值；readonly修饰的常量可以不初始化值，且可以延迟到构造函数。</li> <li>cons修饰的常量在编译期间会被解析，并将常量的值替换成初始化的值；而readonly延迟到运行的时候。</li> <li>const修饰的常量注重的是效率；readonly修饰的常量注重灵活。</li> <li>const修饰的常量没有内存消耗；readonly因为需要保存常量，所以有内存消耗。</li> <li>const只能修饰基元类型、枚举类、或者字符串类型;readonly却没有这个限制。</li></ul> <h4 id="_32-值类型、引用类型"><a href="#_32-值类型、引用类型" class="header-anchor">#</a> 32.值类型、引用类型</h4> <ol><li><p>值类型(ValueType)
值类型包括：数值类型，结构体，bool型，用户定义的结构体，枚举，可空类型。<br>
值类型的变量直接存储数据，分配在托管栈中。变量会在创建它们的方法返回时自动释放，例如在一个方法中声明Char型的变量name=’C’，当实例化它的方法结束时，name变量在栈上占用的内存就会自动释放
C#的所有值类型均隐式派生自System.ValueType。</p></li> <li><p>引用类型(ReferenceType)
引用类型包括：数组，用户定义的类、接口、委托，object，字符串，null类型，类。<br>
引用类型的变量持有的是数据的引用，数据存储在数据堆，分配在托管堆中，变量并不会在创建它们的方法结束时释放内存，它们所占用的内存会被CLR中的垃圾回收机制释放。</p></li></ol> <h4 id="_33-装箱和拆箱"><a href="#_33-装箱和拆箱" class="header-anchor">#</a> 33.装箱和拆箱</h4> <ul><li><p>装箱就是将一个值类型转换成等值的引用类型<br>
在堆上为新生成的对象(该对象包含数据，对象本身没有名称)分配内存。<br>
将堆栈上值类型变量的值拷贝到堆上的对象中。<br>
将堆上创建的对象的地址返回给引用类型变量(从程序员角度看，这个变量的名称就好像堆上对象的名称一样)。</p></li> <li><p>拆箱就是将一个引用类型转换成等值的值类型<br>
将引用类型变量堆上的值拷贝到栈上面。</p></li></ul> <h4 id="_34-ref与out"><a href="#_34-ref与out" class="header-anchor">#</a> 34.ref与out</h4> <p>ref和out都是按地址传递,使用后都将改变原来参数的数值。</p> <h5 id="ref关键字"><a href="#ref关键字" class="header-anchor">#</a> ref关键字</h5> <ol><li>方法定义和调用方法都必须显式使用 ref 关键字</li> <li>传递到 ref 参数的参数必须初始化,否则程序会报错</li> <li>通过ref的这个特性,一定程度上解决了C#中的函数只能有一个返回值的问题</li></ol> <h5 id="out关键字"><a href="#out关键字" class="header-anchor">#</a> out关键字</h5> <p>方法定义和调用方法都必须显式使用 out关键字</p> <ol><li>方法定义和调用方法都必须显式使用 out关键字</li> <li>out关键字无法将参数值传递到out参数所在的方法中,只能传递参数的引用(个人理解),所以out参数的参数值初始化必须在其方法内进行,否则程序会报错</li> <li>通过out的这个特性,一定程度上解决了C#中的函数只能有一个返回值的问题</li></ol> <h4 id="_35-new和override的区别"><a href="#_35-new和override的区别" class="header-anchor">#</a> 35.new和override的区别</h4> <ul><li>override是指“覆盖”，是指子类覆盖了父类的方法。子类的对象无法再访问父类中的该方法。</li> <li>new是指“隐藏”，是指子类隐藏了父类的方法，当然，通过一定的转换，可以在子类的对象中访问父类的方法。</li></ul> <h4 id="_36-attribute介绍"><a href="#_36-attribute介绍" class="header-anchor">#</a> 36.Attribute介绍</h4> <blockquote><p>MSDN中定义为：公共语言运行时运行添加类似关键字的描述声明，叫做Attribute，它对程序中的元素进行标注，如类型、方法、字段和属性等。attribute和Microsoft.Net Framework文件的元数据保存在一起，可以用来在运行时描述你的代码，或者在程序运行时影响应用程序的行为。</p></blockquote> <p>我们简单地总结：定制特性attribute，本质上是一个类，其为目标元素提供关联附加信息，并在运行时以反射的方式来获取附件信息。</p> <h5 id="attribute通用规则"><a href="#attribute通用规则" class="header-anchor">#</a> attribute通用规则</h5> <ol><li>特性可以应用的目标元素包括：程序集(assemby)、模块(module)、类型(Type)、属性(Property)、事件(Event)、字段(Field)、方法(Method)、参数(param)、返回值(return).</li> <li>特性以[,]形式展示。放在紧挨着元素上</li> <li>attribute实例，是在编译期进行初始化，而不是运行期。</li></ol> <h4 id="_37-c-net内置委托"><a href="#_37-c-net内置委托" class="header-anchor">#</a> 37.C# .NET内置委托</h4> <h5 id="委托是什么"><a href="#委托是什么" class="header-anchor">#</a> 委托是什么</h5> <p>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</p> <p>委托是一种特殊的类型（class），用途是来实现对一种方法的封装。在某种事件发生时，自动调用该方法。好处显然易见，它使用户可以自定义自己的方法实现，通过封装，CLR会在相应事件激发时调用你定义的方法，实现你的功能。</p> <p>C#内置委托 Action、Action&lt;T&gt;、Func&lt;T&gt;、Predicate&lt;T&gt;<br>
CLR环境中给我们内置了几个常用委托Action、 Action&lt;T&gt;、Func&lt;T&gt;、Predicate&lt;T&gt;，一般我们要用到委托的时候，尽量不要自己再定义一 个委托了，就用系统内置的这几个已经能够满足大部分的需求，且让代码符合规范。</p> <h4 id="_38-什么是aop"><a href="#_38-什么是aop" class="header-anchor">#</a> 38.什么是AOP?</h4> <p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
<a href="https://www.cnblogs.com/jingzhishen/p/4980551.html" target="_blank" rel="noopener noreferrer">AOP面向切面编程链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_39-asp-net-mvc-filter"><a href="#_39-asp-net-mvc-filter" class="header-anchor">#</a> 39.Asp.Net MVC -Filter</h4> <p><img src="https://gitee.com/uploads/images/2018/0610/230122_a4f53f9e_1248390.png" alt="输入图片说明" title="11225919-d945fcabe763410a8303810573863fff.png"></p> <h4 id="_40-lock-应锁定什么类型对象"><a href="#_40-lock-应锁定什么类型对象" class="header-anchor">#</a> 40.lock 应锁定什么类型对象</h4> <p>首先先上官方Msdn的说法</p> <blockquote><p>lock 关键字可确保当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线程尝试进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。<br>
lock 关键字在块的开始处调用 Enter，而在块的结尾处调用 Exit。 ThreadInterruptedException 引发，如果 Interrupt 中断等待输入 lock 语句的线程。
通常，应避免锁定 public 类型，否则实例将超出代码的控制范围。<br>
常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (&quot;myLock&quot;) 违反此准则：<br>
如果实例可以被公共访问，将出现 lock (this) 问题。<br>
如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。<br>
由于进程中使用同一字符串的任何其他代码都将共享同一个锁，所以出现 lock(&quot;myLock&quot;) 问题。<br>
最佳做法是定义 private 对象来锁定, 或 private static 对象变量来保护所有实例所共有的数据。<br>
在 lock 语句的正文不能使用 等待 关键字。</p></blockquote> <p>打个比方，有这样一个情景，很多公司所在的大厦的厕所的蹲位都是小单间型的，也就是一次只能进去一个人，那么为了避免每次进去一个人，那怎么做呢？不就是一个人进去之后顺手把门锁上么？这样你在里面干啥事，外边的人也只能等待你解放完了，才能进入。而蹲位的资源（蹲位，手纸等）是共享的。</p> <p>最常使用的锁是如下格式的代码段：</p> <div class="language-CSharp extra-class"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">object</span></span> objlock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">object</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">lock</span> <span class="token punctuation">(</span>objlock <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//要执行的代码逻辑</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么锁的对象是私有的呢？还是以厕所为例子吧，私有就好比，这把锁只有你能访问到，而且最好这把锁不会因为外力而有所改变，别人访问不到，这样才能保证你进去了，别人就进不去了，如果是公有的，就好比你蹲位小单间的锁不是安装在里面而是安装在外边的，别人想不想进就不是你所能控制的了，这样也不安全。</p> <h5 id="关于lock的介绍就到这里-有下面几点需要注意的地方"><a href="#关于lock的介绍就到这里-有下面几点需要注意的地方" class="header-anchor">#</a> 关于lock的介绍就到这里，有下面几点需要注意的地方</h5> <ol><li>lock的是引用类型的对象，string类型除外。</li> <li>lock推荐的做法是使用静态的、只读的、私有的对象。</li> <li>保证lock的对象在外部无法修改才有意义，如果lock的对象在外部改变了，对其他线程就会畅通无阻，失去了lock的意义。</li></ol> <h4 id="_41-rabbitmq-优点"><a href="#_41-rabbitmq-优点" class="header-anchor">#</a> 41.RabbitMQ 优点</h4> <ul><li>安装部署简单，上手门槛低，功能丰富，符合AMQP标准；</li> <li>企业级消息队列，经过大量实践考验的高可靠；</li> <li>集群易扩展，可以轻松的增减集群节点；</li> <li>有强大的WEB管理页面。</li></ul> <blockquote><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。
什么是AMQP 高级消息队列协议使得遵从该规范的客户端应用和消息中间件服务器的全功能互操作成为可能。</p></blockquote> <hr> <h4 id="_42-javascript"><a href="#_42-javascript" class="header-anchor">#</a> 42.javascript</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//快速排序 递归</span>
<span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到中间数的索引值，如果是浮点数，则向下取整</span>
    <span class="token keyword">var</span> numValue <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找到中间数的值</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>numValue <span class="token punctuation">)</span><span class="token punctuation">{</span>            
            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//基准点的左边的数传到左边数组</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//基准点的右边的数传到右边数组</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>numValue<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归不断重复比较</span>
<span class="token punctuation">}</span>
<span class="token comment">// parseInt 实现 </span>
<span class="token keyword">function</span> <span class="token function">_parseInt</span> <span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> radix</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> str_type <span class="token operator">=</span> <span class="token keyword">typeof</span> str
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>str_type <span class="token operator">!==</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> str_type <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果类型不是 string 或 number 类型返回NaN</span>
     <span class="token keyword">return</span> <span class="token number">NaN</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 字符串处理</span>
  str <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> length <span class="token operator">=</span> str<span class="token punctuation">.</span>length
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果为空则返回 NaN</span>
    <span class="token keyword">return</span> <span class="token number">NaN</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>radix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 radix 为0 null undefined</span>
    <span class="token comment">// 则转化为 10</span>
    radix <span class="token operator">=</span> <span class="token number">10</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> radix <span class="token operator">!==</span> <span class="token string">'number'</span> <span class="token operator">||</span> radix <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> radix <span class="token operator">&gt;</span> <span class="token number">36</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">NaN</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
    res <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>radix<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

<span class="token comment">//获取url参数返回object对象</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> _array <span class="token operator">=</span> location<span class="token punctuation">.</span>href<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_array<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">var</span> array <span class="token operator">=</span> _array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">var</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>
     obj<span class="token punctuation">[</span>temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> _array <span class="token operator">=</span> location<span class="token punctuation">.</span>href<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">([^?&amp;=]+)=([^?&amp;=]*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_array<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> _array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">var</span> temp <span class="token operator">=</span> _array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>
           obj<span class="token punctuation">[</span>temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//去除空格</span>
string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(^\s*)|(\s*$)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//call()方法和apply()</span>
<span class="token comment">//1. 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。</span>
<span class="token comment">//2. 相同点：这两个方法的作用是一样的。</span>
<span class="token comment">//3. 不同点：接收参数的方式不同。</span>
<span class="token comment">//apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。</span>
<span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span>thisObj <span class="token punctuation">[</span><span class="token punctuation">,</span>argArray<span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//call()方法 第一个参数和apply()方法的一样，但是传递给函数的参数必须列举出来。</span>
<span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span>thisObject<span class="token punctuation">[</span><span class="token punctuation">,</span>arg1 <span class="token punctuation">[</span><span class="token punctuation">,</span>arg2 <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">,</span>argn<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//闭包</span>
<span class="token comment">//定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。</span>
<span class="token comment">//表现形式：使函数外部能够调用函数内部定义的变量。</span>
<span class="token comment">//什么是跨域？</span>
<span class="token comment">//由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域</span>
<span class="token comment">//porxy代理 通过nginx代理</span>
<span class="token comment">//CORS 【Cross-Origin Resource Sharing】</span>
res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;Content-Type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;text/html; charset=UTF-8&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;Access-Control-Allow-Origin&quot;</span><span class="token operator">:</span><span class="token string">'http://localhost'</span><span class="token punctuation">,</span>
    <span class="token string-property property">'Access-Control-Allow-Methods'</span><span class="token operator">:</span> <span class="token string">'GET, POST, OPTIONS'</span><span class="token punctuation">,</span>
    <span class="token string-property property">'Access-Control-Allow-Headers'</span><span class="token operator">:</span> <span class="token string">'X-Requested-With, Content-Type'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//jsonp</span>
<span class="token keyword">function</span> <span class="token function">testjsonp</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取返回的结果</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> _script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/javascript&quot;</span><span class="token punctuation">;</span>
_script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://localhost:8888/jsonp?callback=testjsonp&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>_script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div></div>  <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/interView/java/004/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Java架构师面试高频问题1~18</div></a> <a href="/pages/interView/DB/001/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Oracle面试题1~33</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/interView/java/004/" class="prev">Java架构师面试高频问题1~18</a></span> <span class="next"><a href="/pages/interView/DB/001/">Oracle面试题1~33</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:qingshansima@outlook.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/qingshansima" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
    Copyright © 2024-2023
    <span>飞翔的土肥猿 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7d1116cd.js" defer></script><script src="/assets/js/2.f6c26bfc.js" defer></script><script src="/assets/js/3.7a437186.js" defer></script><script src="/assets/js/10.046d08d1.js" defer></script>
  </body>
</html>
