(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{334:function(n,t,r){"use strict";r.r(t);var e=r(7),a=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("blockquote",[t("p",[n._v("本文收集自网络，原出处不明。")])]),n._v(" "),t("h2",{attrs:{id:"_1-开发中主要使用-spring-的什么技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-开发中主要使用-spring-的什么技术"}},[n._v("#")]),n._v(" 1. 开发中主要使用 Spring 的什么技术 ?")]),n._v(" "),t("p",[n._v("①. IOC 容器管理各层的组件\n②. 使用 AOP 配置声明式事务\n③. 整合其他框架.")]),n._v(" "),t("h2",{attrs:{id:"_2-简述-aop-和-ioc-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-简述-aop-和-ioc-概念"}},[n._v("#")]),n._v(" 2. 简述 AOP 和 IOC 概念")]),n._v(" "),t("p",[n._v("AOP: Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器)\n也是一种 AOP. AOP 是一种新的方法论, 是对传统 OOP(Object-Oriented\nProgramming, 面向对象编程) 的补充. AOP 的主要编程对象是切面(aspect),\n而切面模块化横切关注点.可以举例通过事务说明.")]),n._v(" "),t("p",[n._v("IOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转\n资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为\n回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送\n给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行\n为也被称为查找的被动形式")]),n._v(" "),t("h2",{attrs:{id:"_3-在-spring-中如何配置-bean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-在-spring-中如何配置-bean"}},[n._v("#")]),n._v(" 3. 在 Spring 中如何配置 Bean ?")]),n._v(" "),t("p",[n._v("Bean 的配置方式: 通过全类名（反射）、通过工厂方法（静态工厂方法 & 实\n例工厂方法）、FactoryBean")]),n._v(" "),t("h2",{attrs:{id:"_4-ioc-容器对-bean-的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-ioc-容器对-bean-的生命周期"}},[n._v("#")]),n._v(" 4. IOC 容器对 Bean 的生命周期")]),n._v(" "),t("p",[n._v("①. 通过构造器或工厂方法创建 Bean 实例\n②. 为 Bean 的属性设置值和对其他 Bean 的引用\n③ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的\npostProcessBeforeInitialization 方法\n④. 调用 Bean 的初始化方法(init-method)\n⑤ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的\npostProcessAfterInitialization 方法\n⑦. Bean 可以使用了\n⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method)")]),n._v(" "),t("h2",{attrs:{id:"_5-spring-如何整合-struts2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-spring-如何整合-struts2"}},[n._v("#")]),n._v(" 5. Spring 如何整合 Struts2 ?")]),n._v(" "),t("p",[n._v("整合 Struts2, 即由 IOC 容器管理 Struts2 的 Action:")]),n._v(" "),t("blockquote",[t("p",[n._v("安装 Spring 插件: 把 struts2-spring-plugin-2.2.1.jar 复制到\n当前 WEB 应用的 WEB-INF/lib 目录下\n在 Spring 的配置文件中配置 Struts2 的 Action 实例\n在 Struts 配置文件中配置 action, 但其 class 属性不再指向该\nAction 的实现类, 而是指向 Spring 容器中 Action 实例的 ID")])]),n._v(" "),t("h2",{attrs:{id:"_6-spring-如何整合-hibernate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring-如何整合-hibernate"}},[n._v("#")]),n._v(" 6. Spring 如何整合 Hibernate")]),n._v(" "),t("p",[n._v("整合 Hibernate, 即由 IOC 容器生成 SessionFactory 对象, 并使用\nSpring 的声明式事务")]),n._v(" "),t("blockquote",[t("p",[n._v("利用 LocalSessionFactoryBean 工厂 Bean, 声明一个使用 XML 映\n射文件的 SessionFactory 实例.\n利用 HibernateTransactionManager 配置 Hibernate 的事务管理器")])]),n._v(" "),t("h2",{attrs:{id:"_7-spring-mvc-比较-struts2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring-mvc-比较-struts2"}},[n._v("#")]),n._v(" 7. Spring MVC 比较 Struts2")]),n._v(" "),t("p",[n._v("①. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter\n②. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计,\n而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.\n③. Spring MVC 使用更加简洁, 开发效率 Spring MVC 确实比 struts2 高:\n支持 JSR303, 处理 ajax 的请求更方便\n④. Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些.")]),n._v(" "),t("h2",{attrs:{id:"_8-spring-mvc-的运行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-spring-mvc-的运行流程"}},[n._v("#")]),n._v(" 8. Spring MVC 的运行流程")]),n._v(" "),t("p",[n._v("①. 在整个 Spring MVC 框架中， DispatcherServlet 处于核心位置，负\n责协调和组织不同组件以完成请求处理并返回响应的工作\n②. SpringMVC 处理请求过程：")]),n._v(" "),t("blockquote",[t("p",[n._v("若一个请求匹配 DispatcherServlet 的请求映射路径(在 web.xml\n中指定), WEB 容器将该请求转交给 DispatcherServlet 处理\nDispatcherServlet 接收到请求后, 将根据请求信息(包括 URL、HTTP\n方法、请求头、请求参数、Cookie 等)及 HandlerMapping 的配置找到处理请求\n的处理器(Handler). 可将 HandlerMapping 看成路由控制器，将 Handler 看成\n目标主机。\n当 DispatcherServlet 根据 HandlerMapping 得到对应当前请求的\nHandler 后，通过 HandlerAdapter 对 Handler 进行封装，再以统一的适配器\n接口调用 Handler。\n处 理 器 完 成 业 务 逻 辑 的 处 理 后 将 返 回 一 个 ModelAndView 给\nDispatcherServlet, ModelAndView 包含了视图逻辑名和模型数据信息\nDispatcherServlet 借助 ViewResoler 完成逻辑视图名到真实视图\n对象的解析\n得到真实视图对象 View 后, DispatcherServlet 使用这个 View 对\nModelAndView 中的模型数据进行视图渲染")])]),n._v(" "),t("h2",{attrs:{id:"_9-说出-spring-mvc-常用的-5-个注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-说出-spring-mvc-常用的-5-个注解"}},[n._v("#")]),n._v(" 9. 说出 Spring MVC 常用的 5 个注解")]),n._v(" "),t("p",[n._v("@RequestMapping 、 @PathVariable 、 @RequestParam 、 @RequestBoy 、\n@ResponseBody")]),n._v(" "),t("h2",{attrs:{id:"_10-如何使用-springmvc-完成-json-操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何使用-springmvc-完成-json-操作"}},[n._v("#")]),n._v(" 10. 如何使用 SpringMVC 完成 JSON 操作")]),n._v(" "),t("p",[n._v("①. 配置 MappingJacksonHttpMessageConverter\n②. 使用 @RequestBody 注解或 ResponseEntity 作为返回值")])])}),[],!1,null,null,null);t.default=a.exports}}]);